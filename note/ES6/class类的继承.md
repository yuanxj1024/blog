# Class 类的继承


## 基础

可以使用 **extends** 关键字

**super()** 表示 父类的构造函数，只能在 constructor() 中使用
- 原因是： 子类的this对象，必须先通过父类的构造函数完成塑造，获得父类属性、方案后，再进行加工

- ES5 的继承机制(**实例在前，继承在后**),是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面
- ES6 的继承机制(**继承在前，实例在后**)，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例


## 私有属性、方法的继承

子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用


## 静态属性、方法

静态属性是通过浅拷贝实现继承的。

如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象，因为浅拷贝只会拷贝对象的内存地址。



## Object.getPrototypeOf()

Object.getPrototypeOf()方法可以用来从子类上获取父类


## super

- 作为构造函数
- 作为对象时，指向父类的原型对象,在静态方法中指向父类

## prototype、\_\_proto__

Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。

作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。

```
B.prototype = Object.create(A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;
```